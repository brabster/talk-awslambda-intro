<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>AWS Lambda</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <!--

      -->
    <div class="reveal">
      <div class="slides">
        <section>
          <section data-markdown>
            ## What is AWS Lambda?
          </section>
          <section data-markdown>
            ## Functions-As-A-Service

            * run code
            * in response to events
            * to do stuff
            * without servers
          </section>
          <section data-markdown>
            ## Run what code?

            * NodeJS 4.3 (and 0.10.48)
            * Python 2.7
            * Java 8
            * ...think microservices

            Note:
            Node 0.10.48 runtime at EOL Oct 2016
          </section>
          <section data-markdown>
            ## Run what code?

            Setup code and an "event handler"
          </section>
          <section data-markdown>
            ## Run what code?

            To give you an idea of the Lambda API

            ```
            exports.handler = function(event, context) {
              console.log('Hello', event.name, '!');
            }
            ```

            ```
            def my_handler(event, context):
              print('Hello {}!'.format(event['name']))
            ```

            ```
            package ...
            import ...
            public class Hello {
              public void handler(String name, Context context) {
                System.out.println(String.format("Hello %s!", name));
              }
            }
            ```
          </section>
          <section data-markdown>
            ## Events?

            A standard interface for
            * direct invocation
            * notifications
            * schedules
            * streams
          </section>
          <section data-markdown>
            ## To do stuff?

            * post to Slack
            * implement an API endpoint
            * copy records into Elasticsearch
            * insert records into a database
            * perform a healthcheck
            * deploy some stuff
            * ... and so on
          </section>
          <section data-markdown>
            ## Without servers?

            * well, sort of
            * it runs on servers really
            * you don't manage the servers
            * you pay for processing time
          </section>
          <section data-markdown>
            ## Pricing example

            * 1x t2.micro Linux instance
            * In us-east-1
            * $14.64 per month

            Note:
            Pricing examples as at July 2016
          </section>
          <section data-markdown>
            ## Pricing example

            * 10,000 invocations per month
            * 1.5Gb memory
            * 500ms per invocation

            = $0.13 per month ($0.000_002_501 per request)
          </section>
          <section data-markdown>
            ## Pricing example

            Free tiers

            * First 750h of t2.micro instance usage
            * First 1m Lambda invocations
          </section>
        </section>
        <section>
          <section data-markdown>
            ##  Srsly?

            What's the catch?
          </section>
          <section data-markdown>
            ## Latency

            * startup time (esp. JVM)
            * once started, may be reused
            * not for highly latency-sensitive applications
          </section>
          <section data-markdown>
            ## Timeouts

            * must set a timeout, up to 5 mins
            * not suitable for potentially long-running tasks
            * unless they can be broken down
          </section>
          <section data-markdown>
            ## Limits

            * Subject to AWS limits
            * at most 100 running functions
            * impacted by other limits
             * eg. # of Kinesis partitions limits consuming Lambdas
            * limits can be increased on request to AWS
          </section>
          <section data-markdown>
            ## Lock-in

            * [Google Functions (currently Alpha)](https://cloud.google.com/functions/)
            * [Azure Functions (currently Preview)](https://azure.microsoft.com/en-gb/services/functions)
            * similar but incompatible APIs

            Note:
            Not just the Lambda APIs - also coupling to the producing/comsuming services like Kinesis for data formats
          </section>
          <section data-markdown>
            ## Ecosystem Maturity

            * or lack thereof
            * good practices pending
            * comprehensive CLI/CloudFormation support
            * immature third-party tooling
            * eg. testing, deployment
          </section>
        </section>
        <section>
          <section data-markdown>
            ## It's a Lambda Function's Life

            Somewhere in the cloud, an event makes its way towards your new Lambda function...

          </section>
          <section data-markdown>
            ## Before the first event...

            * you create your function
            * upload it on the console
            *
          </section>
          <section data-markdown>
            ## When the first event arrives

            * Your function is deployed
            * Then, it's run with the event
            * So it's slow
            * But you can initialize stuff
          </section>
          <section data-markdown>
            ## When another event arrives...

            * Your function may already be running, so
              * No deployment time
              * No init to run
              * Just run the handler function with the new event
              * So it's fast
          </section>
          <section data-markdown>
            ## Or...

            * Another instance might be deployed
            * So it could still be slow
          </section>
          <section data-markdown>
            ## If the function errors

            * The event will be retried
            * Retry strategy varies by event type
              * Push invocations retry three times
              * Pull invocations will retry indefinitely
            * Thoughtful error handling needed!
            * Not to mention monitoring...
          </section>
          <section data-markdown>
            ## Fast Invocation

            * Time on the order of...
            * Plus your compute time
            * Happens when an instance is running, waiting to process
          </section>
          <section data-markdown>
            ## Slow Invocation

            * Time anything from ms to several seconds
            * Fastest for (nodejs?)
            * Much slower for JVM (start time)
            * Slowest for other JVM languages (start time + large artifacts)
          </section>
          <section data-markdown>
            ## Fast or Slow?

            * Surprise!
            * You can't tell beforehand
            * Under load
              * expect many more fast invocations than slow ones
              * after startup
          </section>
        </section>
        <section>
          <section data-markdown>
            ## Lambda Triggers

            What kinds of events can invoke a Lambda function?
          </section>
          <section data-markdown>
            ## Direct invocation (Push)

            * Mash the test button
            * Call InvokeFunction using SDK or CLI
            * Retries on error twice (three total attempts)
            * Same retry strategy for all push triggers
          </section>
          <section data-markdown>
            ## CloudWatch Events (Push)

            * enables scheduled invocation
            * cron/rate
            * specify event content
          </section>
          <section data-markdown>
            ## API Gateway (Push)

            * HTTP APIs
            * invoking Lambda functions
            * powerful, feature-rich
            * slow startup could be an issue
            * could be a whole talk on its own
          </section>
          <section data-markdown>
            ## SNS Notification (Push)

            * simple Notification Service
            * pub/sub
            * venerable AWS Service
            * supports any service producing SNS messages
              * S3
              * CloudWatch logs/alarms
              * CloudFormation
          </section>
          <section data-markdown>
            ## Kinesis Stream (Pull)

            * pull batches of records from Kinesis
            * keep retrying indefinitely on error
          </section>
          <section data-markdown>
            ## Kinesis Stream (Pull)

            * pull batches of records from Kinesis
            * keep retrying indefinitely on error
          </section>
          <section data-markdown>
            ## DynamoDB Stream (Pull)

            * react to writes
            * tables and indexes
          </section>
        </section>
        <section>
          <section data-markdown>
            ## Environmentally Unfriendly?

            What does a Lambda's runtime environment look like?
          </section>
          <section data-markdown>
            ## The context provides

            * invoked Lambda function ARN
            * request ID
            * allocated memory, time remaining, etc.
          </section>
          <section data-markdown>
            ## You don't have...

            * environment variables
            * config files

            (so Lambdas are 11-factor apps?)
          </section>
          <section data-markdown>
            ## configure all the things

            * so you wrote the code
            * how do you configure it?

            Note:
            There's no way to configure the same Lambda function in different ways
          </section>
          <section data-markdown>
            ## Include the Batteries?

            * pack config up as part of build and/or deployment
            * but then not the same artifact
            * does it matter?
          </section>
          <section data-markdown>
            ## Look it up?

            * store config somewhere else (like s3)
            * indexed by lambda ARN
            * but extra call at runtime
            * init+memoize?
          </section>
          <section data-markdown>
            ## Configure the Trigger?

            * include config in the triggering "event"
            * might work well for manual invocation
            * might mix config with data
            * harder to reason about lambda "pipelines"
          </section>
          <section data-markdown>
            ## Approach 'n'

            * your solution here?
            * wait for AWS to solve the problem
            * see if other providers do better
          </section>
        </section>
        <section>
          <section data-markdown>
            ## Enough Dev, let's talk Ops
          </section>
          <section data-markdown>
            ## Automation

            * CLI and CloudFormation support
            * CRUD functions
            * Publish versions
            * Assign aliases
          </section>
          <section data-markdown>
            ## Permissions

            * IAM policies and roles
            * Different for push and pull invocation
            * Push needs permissions to invoke the function
            * Lambda needs permissions to invoke the pull resource
          </section>
          <section data-markdown>
            ## Testing in the Cloud

            * Configure Sample Event
            * Mash the test button
            * Look at the logs
            * Beware of side effects
          </section>
          <section data-markdown>
            ## Testing Locally

            * Technically straightforward
            * Harder with Java
            * Glue code may be tough to unit test usefully
            * Docker might help (fake-s3, dynamodb-local, etc.)
          </section>
          <section data-markdown>
            ## How much does it cost?

            * pay for compute time used
            * rounded to next 100ms
            * could be big savings
          </section>
          <section data-markdown>
            ## Aliases and Versions

            * Publish immutable versions
            * Point an Alias at a Version
            * No downtime
            * Easy rollback
            * Sounds great...
          </section>
          <section data-markdown>
            ## Aliases and Versions?

            * Complicates automation
            * Account-global
            * Logs for aliases get mixed up
            * Extra stuff to learn


            Note:
            Cannot reference a version in a different account
          </section>
          <section data-markdown>
            ## State

            * No predictable memory
            * Interesting problems involve remembering stuff
            * Nearest reliable memory is over the network
            * Slooooow
            * Can limit performance and parallelism
          </section>
          <section data-markdown>
            ## Private resources

            * New feature
            * Lambdas run in your subnets
            * Can access private resources
              * RDS databases (postgresql, mysql, etc.)
              * Redshift
              * Elasticsearch
              * ElastiCache (redis/memcached)
              * etc.
          </section>
          <section data-markdown>
            ## Private Resources

            * Can route outbound traffic
            * Perhaps must route outbound traffic!
            * Via NAT instances or NAT Gateway
            * So, known IPs
            * Useful for IP whitelisting
          </section>
          <section data-markdown>
            ## CloudWatch

            * Logs
            * Monitoring
            * Alerts
          </section>
          <section data-markdown>
            ## The Future
          </section>
          <section>
            <section data-markdown>
              ## Learn more

              * [AWS Lambda documentation](https://aws.amazon.com/documentation/lambda/)
              * [AWS Lambda in CloudFormation](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html)
              * [AWS CLI for Lambda](http://docs.aws.amazon.com/cli/latest/reference/lambda/)
              * [AWS Lambda blog](https://aws.amazon.com/blogs/compute/category/aws-lambda/)
              * [Serverless](http://serverless.com/)
              * [Claudia](https://github.com/claudiajs/claudia)
              * [IOpipe](https://www.iopipe.com/)
            </section>
          </section>
          <section>
            scheduling
            event sources multiple
            many aws services are serverless - if you don't need to worry about scaling it
            security
            api gateway
            "recursion" over a stream
          </section>
        </section>
      </div>
    </div>


    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
      history: true,

      // More info https://github.com/hakimel/reveal.js#dependencies
      dependencies: [
      { src: 'plugin/markdown/marked.js' },
      { src: 'plugin/markdown/markdown.js' },
      { src: 'plugin/notes/notes.js', async: true },
      { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
      ]
      });
    </script>
  </body>
</html>
